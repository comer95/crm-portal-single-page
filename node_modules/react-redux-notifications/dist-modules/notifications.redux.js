'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.listen = listen;
exports.unlisten = unlisten;
exports.hide = hide;

exports.default = function () {
  var state = arguments.length <= 0 || arguments[0] === undefined ? { listeningTo: {}, notifications: {} } : arguments[0];
  var action = arguments[1];

  switch (action.type) {
    case LISTEN_TO:
      return Object.assign({}, state, {
        listeningTo: Object.assign({}, state.listeningTo, _defineProperty({}, action.triggeredBy, {
          hideAfter: action.hideAfter,
          defaultMessage: action.defaultMessage,
          showDismiss: action.showDismiss
        }))
      });
    case STOP_LISTEN:
      {
        var _ret2 = function () {
          var newListeningTo = Object.assign({}, state.listeningTo);
          action.actionTypes.forEach(function (actionType) {
            var newCount = state.listeningTo[actionType] - 1;
            newListeningTo[actionType] = newCount === 0 ? undefined : newCount;
          });
          return {
            v: Object.assign({}, state, {
              listeningTo: newListeningTo
            })
          };
        }();

        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
      }
    case SHOW_NOTIFICATION:
      return Object.assign({}, state, {
        notifications: Object.assign({}, state.notifications, _defineProperty({}, action.trigger.type, [].concat(_toConsumableArray(state.notifications[action.trigger.type] || []), [{
          key: action.key,
          message: action.message,
          trigger: action.trigger,
          showDismiss: action.showDismiss
        }])))
      });
    case HIDE_NOTIFICATION:
      {
        var notificationForActionType = state.notifications[action.trigger];
        var filtered = notificationForActionType.filter(function (n) {
          return n.key !== action.key;
        });
        return Object.assign({}, state, {
          notifications: Object.assign({}, state.notifications, _defineProperty({}, action.trigger, filtered.length === 0 ? undefined : filtered))
        });
      }
  }

  return state;
};

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var LISTEN_TO = exports.LISTEN_TO = 'notifications/listenTo';
var STOP_LISTEN = exports.STOP_LISTEN = 'notifications/stopListen';
var SHOW_NOTIFICATION = exports.SHOW_NOTIFICATION = 'notification/showNotification';
var HIDE_NOTIFICATION = exports.HIDE_NOTIFICATION = 'notification/hideNotification';

function listen(options) {
  return Object.assign({}, options, {
    type: LISTEN_TO
  });
}

function unlisten(actionTypes) {
  return {
    type: STOP_LISTEN,
    actionTypes: actionTypes
  };
}

function hide(trigger, key) {
  return {
    type: HIDE_NOTIFICATION,
    trigger: trigger,
    key: key
  };
}

var keySeed = 0;

var middleware = exports.middleware = function middleware(store) {
  return function (next) {
    return function (action) {
      var result = next(action);
      var listener = store.getState().notifications.listeningTo[action.type];
      if (listener) {
        (function () {
          var notificationKey = 'notification_' + keySeed++;
          store.dispatch({
            type: SHOW_NOTIFICATION,
            key: notificationKey,
            trigger: action,
            showDismiss: listener.showDismiss,
            message: action.notificationMessage || listener.defaultMessage
          });

          if (listener.hideAfter) {
            setTimeout(function () {
              store.dispatch({
                type: HIDE_NOTIFICATION,
                trigger: action.type,
                key: notificationKey
              });
            }, listener.hideAfter);
          }
        })();
      }

      return result;
    };
  };
};