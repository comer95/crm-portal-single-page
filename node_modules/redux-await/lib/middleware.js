'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.middleware = exports.getFailedActionType = exports.getPendingActionType = undefined;

var _utils = require('./utils');

var _constants = require('./constants');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var getPendingActionType = exports.getPendingActionType = function getPendingActionType(type) {
  return _constants.AWAIT_MARKER + '/pending/' + type;
};
var getFailedActionType = exports.getFailedActionType = function getFailedActionType(type) {
  return _constants.AWAIT_MARKER + '/fail/' + type;
};

var middleware = exports.middleware = function middleware(_ref) {
  var dispatch = _ref.dispatch;
  return function (next) {
    return function (action) {
      var payload = action.payload;
      var type = action.type;
      var meta = action.meta;

      if (payload && action.AWAIT_MARKER === _constants.AWAIT_MARKER) {
        (function () {

          var promiseKeys = (0, _utils.getPromiseKeys)(payload);
          var scalarValues = (0, _utils.getNonPromiseProperties)(payload);
          var pendingMeta = _defineProperty({}, _constants.AWAIT_META_CONTAINER, { promiseKeys: promiseKeys, scalarValues: scalarValues, status: 'pending' });
          var successMeta = _defineProperty({}, _constants.AWAIT_META_CONTAINER, { promiseKeys: promiseKeys, scalarValues: scalarValues, status: 'success' });
          var failureMeta = _defineProperty({}, _constants.AWAIT_META_CONTAINER, { promiseKeys: promiseKeys, scalarValues: scalarValues, status: 'failure' });

          var newAction = (0, _utils.objectWithoutProperties)(action, ['type', 'payload', 'AWAIT_MARKER']);

          dispatch(_extends({}, newAction, {
            type: getPendingActionType(type),
            meta: _extends({}, meta, pendingMeta, { type: type })
          }));

          var successCallback = function successCallback(payload) {
            dispatch(_extends({}, newAction, {
              type: type,
              payload: payload,
              meta: _extends({}, meta, successMeta)
            }));
          };

          var failureCallback = function failureCallback(error) {
            dispatch(_extends({}, newAction, {
              type: getFailedActionType(type),
              payload: error,
              meta: _extends({}, meta, failureMeta, { type: type })
            }));
          };

          (0, _utils.resolveProps)(payload).then(successCallback, failureCallback);
        })();
      } else {
        next(action);
      }
    };
  };
};