'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _constants = require('./constants');

var _utils = require('./utils');

function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }

var initialState = { statuses: {}, errors: {} };

exports.default = function () {
  var state = arguments.length <= 0 || arguments[0] === undefined ? initialState : arguments[0];
  var action = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  if (action.meta && action.meta[_constants.AWAIT_META_CONTAINER]) {
    var _ret = (function () {
      var awaitMeta = action.meta[_constants.AWAIT_META_CONTAINER];
      var status = awaitMeta.status;

      var statuses = _extends({}, state.statuses);
      var errors = _extends({}, state.errors);
      awaitMeta.promiseKeys.forEach(function (prop) {
        statuses[prop] = status;
        if (status === 'failure') {
          errors[prop] = action.payload;
        } else {
          // only unset errors prop if previously set
          if (errors[prop]) {
            errors[prop] = null;
          }
        }
      });
      return {
        v: { statuses: statuses, errors: errors }
      };
    })();

    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
  }
  return state;
};